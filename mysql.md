# MySQL笔记

## 结构：

​    databases (数据库)
​        tables (表)

## 四种操作

### DDL-数据定义语言

#### 数据库操作

```cpp
show databases;  //查看所有数据库

create databases 数据库名; //创建数据库

use 数据库名; //使用某个数据库

select database(); //查看当前在哪个数据库

drop database 数据库名; //删除数据库
```

#### 表操作

```cpp
show tables; //展示所有表

create table 表名 (字段 字段类型, 字段 字段类型, ...); //创建表

desc 表名; //查看这个表的信息

show create table 表名; //查看这个表的创建信息

alter table 表名 add/modify/change/drop/rename to ...; //添加字段/更新字段类型/更新字段和字段类型/删除字段/改表名

drop table 表名; //删除表
```

### DML-数据操纵语言

#### 添加数据

```cpp
insert into 表名 (字段1, 字段2...) values (值1, 值2...); //给指定字段添加数据

insert into 表名 values (值1, 值2...);  //给全部字段添加数据

insert into 表名 (字段1, 字段2...) values (值1, 值2...), (值1, 值2...), (值1, 值2...);
insert into 表名 values (值1, 值2...), (值1, 值2...), (值1, 值2...); //批量添加数据
```

#### 修改数据

```cpp
updata 表名 set 字段名1 = 值1, 字段名2 = 值2, ... [where 条件];
```

#### 删除数据

```cpp
delete from 表名 [where 条件];
//delete不能删除某一个字段的值(可以使用update)
```

### DQL-数据查询语言

#### 执行顺序

select ④

​    字段列表

from ①

​    表名列表

where ②

​    条件列表

group by ③

​    分组字段列表

having

​    分组后条件列表

order by ⑤

​    排序字段列表

limit ⑥

​    分页参数

### DCL-数据控制语言

#### 管理用户

1、查询用户

​    use mysql;
​    select * from user;

2、创建用户

​    create user '用户名'@'主机名' identified '密码';

3、修改用户密码

​    alter user '用户名'@'主机名' identified with mysql_native_password by '新密码';

4、删除用户

​    drop user '用户名'@'主机名';

#### 控制权限

|        权限         |        说明        |
| :-----------------: | :----------------: |
| ALL, ALL PRIVILEGES |      所有权限      |
|       SELECT        |      查询数据      |
|       INSERT        |      插入数据      |
|       UPDATE        |      修改数据      |
|       DELETE        |      删除数据      |
|        ALTER        |       修改表       |
|        DROP         | 删除数据库/表/视图 |
|       CREATE        |   创建数据库/表    |

1、权限查询

​    show grants for '用户名'@'主机名';

2、授予权限

​    grant 权限列表 on 数据库.表名 to '用户名'@'主机名';

3、撤销权限

​    revoke 权限列表 on 数据库.表名 from '用户名'@'主机名';


### 函数

#### 字符串函数

|               函数                |                           功能                            |
| :-------------------------------: | :-------------------------------------------------------: |
| concat( $s_1 $, $s_2$,..., $s_n$) |   字符串拼接，将$s_1$, $s_2$,..., $s_n$拼接成一个字符串   |
|            lower(str)             |                  将字符串str全部转为小写                  |
|            upper(str)             |                  将字符串str全部转为大写                  |
|         lpad(str, n, pad)         | 左填充，用字符串pad最str的左边进行填充，达到n个字符串长度 |
|         rpad(str, n, pad)         | 右填充，用字符串pad最str的右边进行填充，达到n个字符串长度 |
|             trim(str)             |                去掉字符串头部和尾部的空格                 |
|    substring(str, start, len)     |       返回字符串str从start位置起的len个长度的字符串       |

#### 数值函数

|    函数     |                功能                |
| :---------: | :--------------------------------: |
|   ceil(x)   |              向上取整              |
|  floor(x)   |              向下取整              |
|  mod(x, y)  |           返回x / y的模            |
|   rand()    |        返回0 - 1内的随机数         |
| round(x, y) | 求参数x的四舍五入的值，保留y位小数 |

#### 日期函数

|                函数                |                      功能                       |
| :--------------------------------: | :---------------------------------------------: |
|             curdate()              |                  返回当前日期                   |
|             curtime()              |                  返回当前时间                   |
|               now()                |               返回当前日期和时间                |
|             year(date)             |               获取指定date的年份                |
|            month(date)             |               获取指定date的月份                |
|             day(date)              |               获取指定date的日期                |
| date_add(date, INTERVAL expr type) | 返回一个日期/时间加上一个时间间隔expr后的时间值 |
|       datediff(date1, date2)       |    返回起始时间date1和结束时间date2间的天数     |

#### 流程函数

|                            函数                            |                           功能                            |
| :--------------------------------------------------------: | :-------------------------------------------------------: |
|                       if(val, t, f)                        |            如果value位true，则返回t，否则返回f            |
|                   ifnull(value1, value2)                   |       如果value1不为空，返回value1，否则返回value2        |
|     case when [val1] then [res1] ...else [default] end     |    如果val1为true，返回res1；...否则返回default默认值     |
| case [expr] when [val1] then [res1] ... else [default] end | 如果expr的值等于val1，返回res1；...，否则返回defaul默认值 |



### 约束

#### 概述

1、概念：约束时作用于表中字段上的规则，用于限制存储在表中的数据。
2、目的：保证数据库中数据的正确、有效性和完整性。
3、分类：

|   约束   |                           描述                           |   关键字    |
| :------: | :------------------------------------------------------: | :---------: |
| 非空约束 |                限制该字段的数据不能为null                |  NOT NULL   |
| 唯一约束 |          保证该字段的所有数据都是唯一、不重复的          |   UNIQUE    |
| 主键约束 |         主键时一行数据的唯一标识，要求非空且唯一         | PRIMARY KEY |
| 默认约束 |      保存数据时，如果未指定该字段的值，则采用默认值      |   DEFAULT   |
| 检查约束 |                  保证字段满足某一个条件                  |    CHECK    |
| 外键约束 | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 | FOREIGN KEY |

#### 外键约束

- 添加外键


​    		Alter Table 表名 Add Constraint 外键名称 Foreign Key (外键字段名) References 主表(主表列名);

- 删除外键

​    		Alter Table 表名 drop foreign ket 外键名称;

- 删除/更新行为


|    行为     |                             说明                             |
| :---------: | :----------------------------------------------------------: |
|  NO ACTION  | 当附表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新 |
|  RESTRICT   | 当附表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新 |
|   CASCADE   | 当附表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录 |
|  SET NULL   | 当父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null |
| SET DEFAULT |         父表有变更时，子表将外键列设置成一个默认的值         |


## 多表查询

### 内连接

#### 隐式内连接

​    		Select 字段列表 From 表1，表2 Where 条件...;

#### 显示内连接

​    		Select 字段列表 From 表1 [Inner] Join 表2 On 连接条件...;


### 外连接

#### 左外连接

- 相当于查询表1(左表)的所有数据 包含 表1和表2交集部分的数据


​    		Select 字段列表 From 表1 Left [Outer] Join 表2 On 条件...;

#### 右外连接

- 相当于查询表2(右表)的所有数据 包含 表1和表2交集部分的数据


​    		Select 字段列表 From 表1 Right [Outer] Join 表2 On 条件...;

### 自连接

​			Select 字段列表 From 表A 别名A Join 表A 别名B 条件...;

### 联合查询

- 对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集

​			Select 字段列表 From 表A ...

​			Union [All]

​			Select 字段列表 From 表B ...;

- union all会将全部的数据直接合并在一起，union会对合并之后的数据去重。

- 对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。

### 子查询

- SQL语句中嵌套SELECT语句，称为`嵌套查询`，又称`子查询`。

​			Select * From t1 Where column = (Select column1 From t2);

- 根据子查询结果不同，分为

​			标量子查询（子查询结果为单个值）

​			列子查询（子查询结果为一列）

​			行子查询（子查询结果为一行）

​			表子查询（子查询结果为多行多列）

- 根据子查询位置，分为：Where之后，From之后，Select之后。

#### 标量子查询

子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为`标量子查询`。

常用的操作符： =  <>  >  >=  <  <=

#### 列子查询

子查询返回的结果是一列（可以是多行），这种子查询称为`列子查询`。

| 操作符 |                  描述                  |
| :----: | :------------------------------------: |
|   IN   |      在指定的集合范围之内，多选一      |
| NOT IN |         不在指定的集合范围之内         |
|  ANY   |  子查询返回列表中，有任意一个满足即可  |
|  SOME  | 与ANY等同，使用SOME的地方都可以使用ANY |
|  ALL   |    子查询返回列表的所有值都必须满足    |

#### 行子查询

子查询返回的结果是一行（可以是多列），这种子查询成为`行子查询`。

常用的操作符: =、<>、IN、NOT IN

#### 表子查询

子查询返回的结果是多行多列，这种子查询成为`表子查询`。

常用的操作符: IN

 

## 事务

事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作`要么同时成功`，`要么同时失败`。

### 事务操作

- 查看设置事务提交方式

​			Select @@autocommit;

​			Set @@autocommit = 0;

- 提交事务

​			Commit;

- 回滚事务

​			Rollback;

- 开启事务

​			Start Transaction 或 Begin;

### 事务四大特性

- 原子性

  ​	事务是不可分割的最小操作单元，要么全部成功，要么全部失败

- 一致性

  ​	事务完成时，必须使所有的数据都保持一致状态

- 隔离性

  ​	数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行

- 持久性

  ​	事务一旦提交或回滚，它对数据库中的数据的改变就是永久的

### 并发事务问题

|    问题    |                             描述                             |
| :--------: | :----------------------------------------------------------: |
|    脏读    |           一个事务读到另外一个事务还没有提交的数据           |
| 不可重复读 |      一个事务先后读取同一条记录，但是两次读取的数据不同      |
|    幻读    | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影“。 |

### 事务隔离级别

|       隔离级别        | 脏读 | 不可重复读 | 幻读 |
| :-------------------: | :--: | :--------: | :--: |
|   Read uncommitted    |  √   |     √      |  √   |
|    Read committed     |  ×   |     √      |  √   |
| Repeatable Read(默认) |  ×   |     ×      |  √   |
|     Serializable      |  ×   |     ×      |  ×   |

- 查看事务隔离级别

  ​	Select @@Transaction_isolation;

- 设置事务隔离级别

  ​	Set [Session | Global] Transaction Isolation Level {Read Uncommitted | Read Committed | Repeatable Read | Serializable};





## 存储引擎

### 简介

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。

- 在创建表时，指定存储引擎

  ​	Create Table 表名(

  ​		...		

  ​	) Engine = InnoDB [Commit 表注释];

- 查看当前数据库支持的存储引擎

​			Show Engine;

### 存储引擎特点

- InnoDB
  - 介绍
    - InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MYSQL 5.5 之后，InnoDB是默认的MYSQL存储引擎
  - 特点
    - DML操作遵循ACID模型，支持`事务`；
    - `行级锁`，提高并发访问性能；
    - 支持`外键`FOREIGN KEY约束，保证数据的完整性和正确性；
  - 文件
    - xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。
    - 参数：innodb_file_per_table
- MyISAM
  - 介绍
    - MyISAM是MySQL早期的默认存储引擎
  - 特点
    - 不支持事务，不支持外键
    - 支持表锁，不支持行锁
    - 访问速度快
  - 文件
    - xxx.sdi：存储表结构信息
    - xxx.MYD：存储数据
    - xxx.MYI：存储索引
- Memory
  - 介绍
    - Memory引擎的表数据时存储在`内存`中，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。
  - 特点
    - 内存存放
    - hash索引（默认）
  - 文件
    - xxx.sdi：存储表结构信息

|     特点     |       InnoDB        | MyISAM | Memory |
| :----------: | :-----------------: | :----: | :----: |
|   存储限制   |        64TB         |   有   |   有   |
|   事务安全   |       `支持`        |   -    |   -    |
|    锁机制    |       `行锁`        |  表锁  |  表锁  |
|  B+tree索引  |        支持         |  支持  |  支持  |
|   Hash索引   |          -          |   -    |  支持  |
|   全文索引   | 支持（5.6版本之后） |  支持  |   -    |
|   空间使用   |         高          |   低   |  N/A   |
|   内存使用   |         高          |   低   |  中等  |
| 批量插入深度 |         低          |   高   |   高   |
|   支持外键   |       `支持`        |   -    |   -    |

### 存储引擎选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

- InnoDB：是MySQL的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么其比较合适。
- MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新、删除操作，并且对事务的完整性、并发性要求不是很高，那么其比较合适。
- MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。



## 索引

### 索引概述

索引（index）是帮助MySQL`高效获取数据`的`数据结构`（`有序`）。

|                            优势                             |                       劣势                       |
| :---------------------------------------------------------: | :----------------------------------------------: |
|                     提高数据检索的效率                      |              索引列也要占用磁盘空间              |
| 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 | 索引大大提高了查询效率，同时却也降低更新表的速度 |

### 索引结构

|       索引结构        |                             描述                             |
| :-------------------: | :----------------------------------------------------------: |
|      B+Tree索引       |          最常见的索引类型，大部分引擎都支持B+树索引          |
|       Hash索引        | 底层数据结构使用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 |
|  B-Tree（空间索引）   | 空间索引是MySQL引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text（全文索引） | 是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene,Solr,ES |

|    索引    |     InnoDB      | MyISAM | Memory |
| :--------: | :-------------: | :----: | :----: |
| B+Tree索引 |      支持       |  支持  |  支持  |
|  Hash索引  |     不支持      | 不支持 |  支持  |
| B-Tree索引 |     不支持      |  支持  | 不支持 |
| Full-text  | 5.6版本之后支持 |  支持  | 不支持 |

#### B+Tree

MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，**提高区间访问的性能**。

#### Hash

哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。

如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突，可以通过链表来解决。

### 索引分类

|   分类   |                         含义                         |           特点           |  关键字  |
| :------: | :--------------------------------------------------: | :----------------------: | :------: |
| 主键索引 |               针对表中的主键创建的索引               | 默认自动创建，只能有一个 | PRIMARY  |
| 唯一索引 |           避免同一个表中某数据列中的值重复           |        可以有多个        |  UNIQUE  |
| 常规索引 |                   快速定位特定数据                   |        可以有多个        |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 |        可以有多个        | FULLTEXT |

在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：

|            分类             |                            含义                            |       特点       |
| :-------------------------: | :--------------------------------------------------------: | :--------------: |
| 聚集索引（Clustered Index） |  将数据存储与索引放到了一块，索引结构的叶子结点保存了数据  | 必须有且只有一个 |
| 二级索引（Secondary Index） | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 |   可以存在多个   |

### 索引语法

- 创建索引

  ​	CREATE [UNIQUE | FULLTEXT] INDEX index_name ON table_name (index_col_name, ...);

- 查看索引

  ​	SHOW INDEX FROM table_name;

- 删除索引

  ​	DROP INDEX index_name ON table_name;

### SQL 性能分析

- SQL执行频率		

  ​		MySQL客户端连接成功后，通过show [session | global]  status 命令可以查看提供服务器状态信息。通过如下指令，看一查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次。

  ​			SHOW GLOBAL STATUS LIKE 'Com_______';

- 慢查询日志

  ​		慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。

  ​			slow_query = 1    #开启MySQL慢查询日志开关

  ​			long_query_time = 2    #设置慢查询日志的时间为2秒，SQL语句执行时间超过两秒，就会视为慢查询，记录慢查询日志。

​				配置完毕后，通过一下指令重启MySQL服务器进行测试，查看慢日志文件中记录的信息 /var/lib/mysql/locahost-slow.log

- profile详情

  ​		执行一系列的业务SQL的操作，然后通过如下指令查看指令中的执行耗时：

  ​			show profile;    #查看每一条SQL的耗时基本情况

  ​			show profile for query query_id;   #查看指定query_id 的SQL语句各个阶段的耗时情况

  ​			show prefile cpu for query query_id;    #查看指定query_id的SQL语句CPU的使用情况

- explain执行计划

  各字段含义：

  - Id：select查询的序号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）
  - select_type：表示SELECT的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子连接）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等
  - type：表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all
  - possible_key：显示可能应用在这张表上的索引，一个或多个
  - Key：实际使用的索引，如果为NULL，则没有使用索引。
  - Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好
  - rows：MySQL认为必须要执行查询的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的。
  - filtered：表示范围结果的行数占需读取行数的百分比，filtered的值越大越好

### 索引使用

- 最左前缀法则

  ​	如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，且不跳过索引中的列。如果跳过某一列，**索引将部分失效（后面的字段索引失效）**。

- 范围查询

  ​	联合索引中，出现范围查询（>, <），**范围查询右侧的列索引失效**。	

  ​	防止索引失效，要**使用（>=, <=）**。

- 索引列运算

  ​	不要再索引列上进行运算操作，**索引将失效**。

- 字符串不加引号

  ​    字符串类型字段使用时，不加引号，**索引将失效**。

- 模糊查询

  ​    如果仅仅是**尾部**模糊匹配，索引不会失效。如果是**头部**模糊匹配，**索引将失效**。

- or连接的条件

  ​    用or分隔开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不要会被用到。

- 数据分布影响

  ​    如果MySQL评估使用索引比全表更慢，则不使用索引。

- SQL提示

  ​    SQL提示，是优化数据库的一个重要手段，简单来说，就是SQL语句中加入一些认为的提示来达到优化操作的目的。

  ​    use index;      ignore index;      force index;    #前两个是建议，有可能不被接受，最后一个是强制使用。

  ​    EXPLAIN SELECT * FROM 表名 SQL提示(索引名) WHERE...;

- 覆盖索引

  ​    尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少使用SELECT *。

​			usingindex condition：查找使用了索引，但是**需要**回表查询数据。

​			using where; using index：查找使用了索引，但是需要的数据都在索引列中能找到，所以**不需要**回表查询数据。

- 前缀索引

  ​	当字段类型为字符串（varchar，text）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

  - 语法CREATE INDEX 索引名 ON 表名(column(n));

  - 前缀长度

    ​    可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择，性能也是最好的。

    ​	查看对email截取前几个字符时的选择性：

    ​    	SELECT COUNT(DISTINCT email) / COUNT(*) FROM 表名;

    ​		SELECT COUNT(DISTINCT SUBSTRING(email, 1, 5)) / COUNT(*) FROM 表名;

- 单列索引与联合索引
  - 单列索引：即一个索引只包含单个列
  - 联合索引：即一个索引包含了多个列
  - 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，而非单列索引。

### 索引设计原理

1. 针对于数据量较大，且查询比较频繁的表建立索引。
2. 针对于常作为查询条件（where）、排序(order by)、分组（group by）操作的字段建立索引。
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4. 如果是字符串类型的字段，字段的长度较长时，可以针对于字段的特点，建立前缀索引。
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以索引覆盖，节省存储空间，避免回表，提高查询效率。
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率。
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。

